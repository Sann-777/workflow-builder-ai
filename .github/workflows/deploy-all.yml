name: Deploy All (Complete Pipeline)

on:
  workflow_dispatch:
    inputs:
      skip_infrastructure:
        description: 'Skip infrastructure deployment (use if already deployed)'
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # Step 1: Deploy Infrastructure
  deploy-infrastructure:
    name: 1ï¸âƒ£ Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_infrastructure != 'true'
    outputs:
      frontend_bucket: ${{ steps.outputs.outputs.frontend_bucket }}
      api_url: ${{ steps.outputs.outputs.api_url }}
      cloudfront_id: ${{ steps.outputs.outputs.cloudfront_id }}
      lambda_name: ${{ steps.outputs.outputs.lambda_name }}
    defaults:
      run:
        working-directory: infrastructure
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: |
          terraform plan \
            -var="openai_api_key=${{ secrets.OPENAI_API_KEY || '' }}" \
            -out=tfplan

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      - name: Extract Outputs
        id: outputs
        run: |
          echo "frontend_bucket=$(terraform output -raw frontend_bucket_name)" >> $GITHUB_OUTPUT
          echo "api_url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "lambda_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
          
          echo "::notice::âœ… Infrastructure deployed successfully"

  # Step 2: Deploy Backend
  deploy-backend:
    name: 2ï¸âƒ£ Deploy Backend (Lambda)
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: always() && (needs.deploy-infrastructure.result == 'success' || github.event.inputs.skip_infrastructure == 'true')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get Lambda function name
        run: |
          LAMBDA_NAME=$(aws lambda list-functions --query "Functions[?contains(FunctionName, 'workflow-builder')].FunctionName" --output text | head -n 1)
          echo "LAMBDA_NAME=$LAMBDA_NAME" >> $GITHUB_ENV
          echo "::notice::Lambda function: $LAMBDA_NAME"

      - name: Build Lambda package with Docker
        working-directory: backend
        run: |
          echo "::notice::Building Lambda package with correct x86_64 binaries..."
          docker run --platform linux/amd64 --rm \
            --entrypoint "" \
            -v "$PWD":/var/task \
            -w /var/task \
            public.ecr.aws/lambda/python:3.11 \
            pip install -r requirements-lambda.txt -t package

      - name: Package and Deploy Lambda
        working-directory: backend
        run: |
          cp -r app package/
          cp lambda_handler.py package/
          cd package
          zip -r ../lambda_deployment.zip . -x "*.pyc" "*__pycache__*" > /dev/null
          cd ..
          
          SIZE=$(du -h lambda_deployment.zip | cut -f1)
          echo "::notice::Package size: $SIZE"
          
          aws lambda update-function-code \
            --function-name ${{ env.LAMBDA_NAME }} \
            --zip-file fileb://lambda_deployment.zip \
            --no-cli-pager
          
          aws lambda wait function-updated --function-name ${{ env.LAMBDA_NAME }}

      - name: Update Lambda environment
        run: |
          CLOUDFRONT_URL=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Comment, 'workflow-builder')].DomainName" \
            --output text | head -n 1)
          
          aws lambda update-function-configuration \
            --function-name ${{ env.LAMBDA_NAME }} \
            --environment "Variables={
              APP_NAME='Workflow Builder API',
              APP_VERSION='1.0.0',
              DEBUG='false',
              ALLOWED_ORIGINS='https://$CLOUDFRONT_URL,http://localhost:3000',
              OPENAI_API_KEY='${{ secrets.OPENAI_API_KEY || '' }}',
              AI_MODEL='gpt-4',
              ENVIRONMENT='production'
            }" \
            --no-cli-pager
          
          aws lambda wait function-updated --function-name ${{ env.LAMBDA_NAME }}
          echo "::notice::âœ… Backend deployed successfully"

      - name: Test API
        run: |
          API_URL=$(aws apigatewayv2 get-apis \
            --query "Items[?contains(Name, 'workflow-builder')].ApiEndpoint" \
            --output text | head -n 1)
          
          RESPONSE=$(curl -s "${API_URL}/prod/" || echo "Failed")
          
          if echo "$RESPONSE" | grep -q "Workflow Builder API"; then
            echo "::notice::âœ… API is responding correctly"
          else
            echo "::error::API test failed"
            exit 1
          fi

  # Step 3: Deploy Frontend
  deploy-frontend:
    name: 3ï¸âƒ£ Deploy Frontend (S3 + CloudFront)
    runs-on: ubuntu-latest
    needs: [deploy-backend]
    if: always() && needs.deploy-backend.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get infrastructure details
        run: |
          S3_BUCKET=$(aws s3api list-buckets --query "Buckets[?contains(Name, 'workflow-builder-frontend')].Name" --output text | head -n 1)
          API_URL=$(aws apigatewayv2 get-apis --query "Items[?contains(Name, 'workflow-builder')].ApiEndpoint" --output text | head -n 1)
          CLOUDFRONT_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Comment, 'workflow-builder')].Id" --output text | head -n 1)
          
          echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "API_URL=${API_URL}/prod" >> $GITHUB_ENV
          echo "CLOUDFRONT_ID=$CLOUDFRONT_ID" >> $GITHUB_ENV

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Create production .env
        working-directory: frontend
        run: |
          cat > .env << EOF
          VITE_API_URL=${{ env.API_URL }}
          VITE_APP_NAME=Workflow Builder
          VITE_APP_VERSION=1.0.0
          VITE_ENABLE_AI_GENERATION=true
          VITE_ENABLE_EXPORT_PNG=true
          VITE_ENABLE_VALIDATION=true
          EOF
          echo "::notice::Environment configured with API: ${{ env.API_URL }}"

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Deploy to S3
        working-directory: frontend
        run: |
          aws s3 sync dist/ s3://${{ env.S3_BUCKET }}/ --delete --no-cli-pager
          aws s3 cp s3://${{ env.S3_BUCKET }}/index.html s3://${{ env.S3_BUCKET }}/index.html \
            --cache-control "public, max-age=0, must-revalidate" \
            --metadata-directive REPLACE \
            --no-cli-pager

      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ env.CLOUDFRONT_ID }} \
            --paths "/*" \
            --no-cli-pager
          
          echo "::notice::âœ… Frontend deployed successfully"

  # Step 4: Deployment Summary
  deployment-summary:
    name: 4ï¸âƒ£ Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-frontend]
    if: always() && needs.deploy-frontend.result == 'success'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get deployment URLs
        run: |
          CLOUDFRONT_URL=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Comment, 'workflow-builder')].DomainName" \
            --output text | head -n 1)
          API_URL=$(aws apigatewayv2 get-apis \
            --query "Items[?contains(Name, 'workflow-builder')].ApiEndpoint" \
            --output text | head -n 1)
          
          echo "::notice::=========================================="
          echo "::notice::ðŸŽ‰ DEPLOYMENT SUCCESSFUL!"
          echo "::notice::=========================================="
          echo "::notice::Frontend: https://$CLOUDFRONT_URL"
          echo "::notice::API: ${API_URL}/prod"
          echo "::notice::API Docs: ${API_URL}/prod/docs"
          echo "::notice::=========================================="
          
          # Test both endpoints
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$CLOUDFRONT_URL")
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/prod/")
          
          echo "::notice::Frontend Status: HTTP $FRONTEND_STATUS"
          echo "::notice::API Status: HTTP $API_STATUS"
          
          if [ "$API_STATUS" = "200" ]; then
            echo "::notice::âœ… All systems operational"
          else
            echo "::warning::Some services may need a few minutes to become available"
          fi
